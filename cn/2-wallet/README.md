- 钱包
	- 密钥和地址
		-  NEO使用的哈希函数
 - 生成私钥
 -  ECDSA算法
 -  Base58Check 
 -  助记词
 -  NEO的脚本哈希和地址
	- 钱包文件
		-  NEP6钱包（基于json）
		-  DB3钱包（sqlite）
	- NEO-GUI的使用
	- UTXO 模型
	- 账户模型
		- 个人账户
		- 合约账户


# 了解钱包
在开始与NEO或其他区块链进行交互时，用户必须在他们的本地机器上创建一个唯一的用户“钱包”，以便在网络上发起交易。 这与现代中心化应用程序不同，中心化程序要求用户必须创建一个账户，且账户存储在中心化的服务器上并由服务提供商专门进行管理。 虽然通过钱包可以存取你的NEO，GAS和基于NEO的其他代币，但“钱包”这个名称事实上是取得不太恰当的。 钱包的核心功能是加密公钥/私钥对，用于对NEO网络上出现的数据库交易进行签名和验证。

首先让我们来想想看用户是如何在传统的中心化数据库上执行写操作的，并将这种操作与用户在NEO区块链上执行的写操作进行比较。 这应该有助于消除你认为代币是存储在钱包中，而不是存储在区块链上的这种误解。

## 中心化数据库
在客户端/服务器架构体系中，用户首先会使用身份凭证（如电子邮件/密码组合）来创建一个账户。 然后这些凭证会存储在服务数据库中。 当用户登录到服务系统时，他们会在本地环境中收到一个会话令牌，持有该令牌可以对服务数据库执行写操作。

因此，如果这个中心化的应用程序对应的是银行服务，那么“资金”就会存储在银行的服务器上，你可以通过向银行提供有效凭证来执行转账操作。

### 优点
- >如果用户丢失了凭证信息，服务提供商可以恢复信息
- >电子邮件/密码是一种标准化的用户体验范例，几乎所有互联网用户都习惯使用这种范式

### 缺点
- >将所有用户的凭证都存储在中心化服务器中，这非常容易引发黑客攻击
- >需要为每个服务生成一组单独的凭证

但最为重要的是，正如这句经常在加密货币社区内传播的话。

“不是你的密钥，就不是你的代币”

传统客户端/服务器体系结构的本质意味着终端用户对服务器端数据库中存储的数据几乎没有什么控制权。 虽然这与金融应用程序尤为相关，但它更广泛地适用于一般的用户数据。

## NEO 区块链
对此我们来比较下用户是如何在NEO区块链上执行写操作的。用户首先会生成公钥/私钥对。所生成的密钥对会存储在用户的本地设备上，专用硬件模块中或客户端中的其他位置。这些密钥对永远都不会被远程的服务器获取到。当用户想要在NEO区块链（数据库）上执行写操作时，他们会在本地生成附有其预期操作的交易。例如，操作可以是将1个NEO发送给朋友。然后，他们使用其加密签名对该交易进行签名，签名是通过其公钥对生成的。

之后会对该交易进行验证，验证通过后向网络进行广播，并最终完成写操作。我们可以看到，由于加密签名只能由用户自己生成，因此没有其他实体可以在没有显式授权的情况下，代表用户对远程数据库执行写操作。

 ### 优点
 - >对黑客而言没有可攻击的中心目标。这免去了服务提供商的许多责任
 - >可以在各种服务提供商之间共享用户的公共身份
 - >你的密钥，就是你的代币
### 缺点
 - >如果用户丢了凭证，没有恢复机制可以找回该凭证
 - >对于没有使用过此类系统的用户而言，这是一种新的用户体验模式


总而言之，对钱包更准确地描述应该是作为公钥/私钥对，用于在分布式数据库（区块链）上执行写操作。与典型的客户端/服务器认证体系结构相比，它具有优点也有缺点，但我们相信该系统提供的安全性和用户控制力总体上可以提供更强大的用户体验。

现在让我们来了解一些关于NEO密钥架构的细节。

## 密钥和地址
现在我们已经对钱包的本质有所了解，那么我们又该如何实际生成一个钱包呢？ 首先，我们要生成一个私钥，它就是一个64字符长的十六进制字符串。 代表的是大小范围在0到2 ^ 256（1.15792089e77）之间的数字。 通过这个数字，可以推断出 “账户”的其余部分信息。 出于我们的目的，账户中将包含私钥，WIF（钱包导入格式），公钥和地址。

从技术上来说，这个随机源可以从任何熵源中生成，但它应该通过某种形式的加密数生成算法来生成。 大多数现代编程语言都会通过标准库中提供的安全随机函数来支持某种形式的私钥生成。

对任何钱包软件而言，第一个真正的挑战是从生成的私钥中推断出账户的所有信息。 下面让我们详细介绍下如何生成这些信息。

### WIF
WIF相对来说比较好理解。 在实践中，私钥最终看起来可能会是这样的：
```
0C28FCA386C7A227600B2FE50B7CAEEC86D3BF1FBE471BE89827E19D72AA1D 
```

更好的做法是使用一种可读性更强的方式呈现，所以我们可以将私钥转换为WIF格式，也称为钱包导入格式

```
5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ
```

虽然这仍然不能提供完全的可读性，但肯定会比使用原字符串更好。 WIF还能提供一些基本的错误检查，因此当发送代币到WIF格式的地址时，你更有可能发现错误。 从原始的私钥到WIF格式的转换是通过Base58Check编码算法实现的。

## Base58Check编码
Base58与常见的Base64编码方案类似，只不过它除去了非字母数字的字符以及那些肉眼看起来相似的字符。 例如，0（零），O（大写o），I（大写i）和l（小写L）都在Base58编码方案中删除了。 NEO的Base58编码中可用字符的完整列表是
```
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
```

下面是用Go语言编写的NEO中的检验编码的完整实现
```
func b58checkencode(ver uint8, b []byte) (s string) {
	/* 在原有的字节数据前添加前缀：版本号字节*/
	bcpy := append([]byte{ver}, b...)

	/* 创建一个新的SHA256上下文*/
	sha256_h := sha256.New()

	/* SHA256哈希#1 */
	sha256_h.Reset()
	sha256_h.Write(bcpy)
	hash1 := sha256_h.Sum(nil)

	/* SHA256哈希 #2 */
	sha256_h.Reset()
	sha256_h.Write(hash1)
	hash2 := sha256_h.Sum(nil)

	/* 在字节数据后面添加后缀：哈希的前4个字节*/
	bcpy = append(bcpy, hash2[0:4]...)

	/* 编码Base58字符串*/
	s = b58encode(bcpy)

	/* 遍历字节数组，每遇到值为0的字节，就向字符串前面添加字符1，直到遇到非0的字节*/
	for _, v := range bcpy {
		if v != 0 {
			break
		}
		s = "1" + s
	}

	return s
}
```
执行检验编码的步骤可以分解如下
1. 在字节数组前面添加前缀：版本号字节
2. 使用SHA256算法对产生的十六进制进行两次哈希处理
3. 向添加了版本号后的字节数据后面添加后缀：哈希的前4个字节
4. 将添加了版本号前缀和校验和后缀的的十六进制转换为Base58编码。
5. 如果字节数组有前导为0的字节，则向字符串前面添加字符1

因此，要将上面描述的原始私钥转换成WIF格式，我们可以使用以下这个简单的函数

```
// ToWIF 会将NEO的私钥转换成钱包导入格式字符串
func (priv *PrivateKey) ToWIF() (wif string) {
	/* 查看 https://en.bitcoin.it/wiki/Wallet_import_format */

	/* 将私钥转换成字节*/
	priv_bytes := priv.ToBytes()

	/*将字节转换成带有版本号0x80的Base58Check编码的字符串*/
	wif = b58checkencode(0x80, priv_bytes)

	return wif
}
```

我们可以看到WIF是私钥的一种编码算法，它可以提供基本的错误检查，并通过附加版本号前缀和校验和后缀，以及编码为Base58格式来提高私钥的可读性。


## 导出公钥
加密货币通常会使用称为椭圆曲线加密算法的加密形式。 该算法用于从私钥派生出公钥，而反过来操作在计算上是不可行的。

椭圆曲线方程的形式如下：  
*y^2 = x^3 + ax + b*

比特币使用称为secp256k1的椭圆曲线，而NEO使用的是secp256r1，其中k -- 表示Koblitz，r -- 表示随机。本质上来说，secp256k1的参数选择方式可以带来更高效的计算（以非常小的安全性来换取），而secp256r1的参数则是随机选择的。

secp256k1等式是：
*y^2 = x^3 + 7*

secp256r1 等式是:  
*y^2 = x^3 - 3x + b*, 其中 *b* 为 *41058363725152142129326129780047268409114441015993725554835256314039467401291*

因为在secp256r1中*b*的值非常大，所以下面我们会对secp256k1加以解释，但二者的原理是相同的。

下面是一条secp256k1曲线：

![](https://cdn-images-1.medium.com/max/1600/1*4dcCrlQfGqZECDLy-25fnw.png)

首先，我们解释下如何在椭圆曲线上进行点的加法运算。
给定点*P*和*Q*，我们绘制一条穿过它们的直线，并在曲线和直线的交点上找到第三个点。 然后我们作该点相对x轴的反射点*R*。 
*P + Q = R*  
![](https://cdn-images-1.medium.com/max/1600/1*dErGh_rL2ExM6AX-Rtyb7w.png)

但是在椭圆加密中，我们不是将两个任意点相加，而是将曲线上的指定基准点与该点本身相加。
我们在点*P*处绘制到曲线的切线，然后我们应用与上面相同的规则。
*P + P = 2 * P*  
![](https://cdn-images-1.medium.com/max/1600/1*ffYKgW-4_Paxve3G1HIJXw.png)

请记住，私钥是一个256位的数字？ 基本上来说，公钥就是*P*自加*x*次的结果，其中*x*是我们的私钥。

*X = x * P*, 其中，*X* 是公钥。

要想反过来操作（从*X*和*P*中算出*x*），我们必须不断地对*P*进行自加，直到得到*X*，这平均需要我们做*2 ^ 128*次点的加法直到得到*x*，这在计算上是不可行的。

## ECDSA 签名
椭圆曲线数字签名算法（ECDSA）是通过ECC算法对数字签名算法（DSA）的一种模拟。 它具有速度快，强度可靠，签名短等优点。

简要步骤如下：
假设私钥，公钥和基准点分别为*k*，*K*和*G*。根据ECC算法，我们知道*K = k * G*。

### 签名过程

1. 选择随机数*r*并计算点*r * G(x，y)*。
2. 根据随机数*r*，消息*M*的哈希值*h*，私钥*k*来计算*s =(h + k * x)/ r*。
3. 向接收方发送消息*M*和签名{*r * G*，*s*}。

### 验证过程

1. 接收者接收消息*M*和签名{*r * G(x，y)*，*s*}。
2. 根据收到的消息计算哈希*h*。
3. 使用发送方的公钥*K*计算*h * G / s + x * K / s*并与*r * G*进行比较。如果两者相同，则验证成功。

推导过程如下

![](https://docs.neo.org/developerguide/en/images/blockchain_paradigm/formula_ecdsa.jpg)

## NEO地址
NEO地址由地址脚本生成，该脚本定义了谁可以花费交易输出。
通常使用的脚本的形式如下：
*PUSHBYTES21*操作码（*0x21*）+压缩型公钥（33字节）+ *CHECKSIG*操作码（*0xAC*），意味着输出只能被给定公钥对应的私钥所有者花费。

要从交易脚本中计算出NEO地址：

1. 计算交易脚本的SHA-256哈希值
2. 计算上一个输出的RIPEMD-160哈希值（也就是脚本哈希）
3. 在输出的地址脚本合约哈希前添加版本号0x17，之后做Base58Check编码（意味着结果将以字符A开头）

以下是从公钥生成NEO地址的示例代码：
```
// ToNeoAddress将NEO公钥转换为NEO地址字符串。
func (pub *PublicKey) ToNeoAddress() (address string) {
	/* 将公钥转换成字节*/
	pub_bytes := pub.ToBytes()

	pub_bytes = append([]byte{0x21}, pub_bytes...)
	pub_bytes = append(pub_bytes, 0xAC)

	/* SHA256哈希*/
	sha256_h := sha256.New()
	sha256_h.Reset()
	sha256_h.Write(pub_bytes)
	pub_hash_1 := sha256_h.Sum(nil)

	/* RIPEMD-160哈希*/
	ripemd160_h := ripemd160.New()
	ripemd160_h.Reset()
	ripemd160_h.Write(pub_hash_1)
	pub_hash_2 := ripemd160_h.Sum(nil)

	program_hash := pub_hash_2
	
	/* 将哈希字节转换成Base58Check编码的序列*/
	address = B58checkencodeNEO(0x17, program_hash)

	return address
}
```

智能合约中通常使用的公共标识符是脚本哈希，而不是地址。由于字节数组的使用很常见，因为Base58编码版本是为了让人类而不是计算机读取的，因此它更有意义！

## 助记词
在NEO生态系统中助记词的使用并不常见，由于没有NEP提议使用助记词词组进行种子推导，所以这部分就省略了。

## NEP-6文件
将原始的私钥存储在磁盘上会有安全隐患。任何可以访问原始私钥的人都可以使用这些资金。而通过使用密码对这些密钥进行加密会是一种更为安全的做法。出于这个原因，我们提供了NEP-2标准格式（https://github.com/neo-project/proposals/blob/master/nep-2.mediawiki）

该加密密钥为原始私钥提供了一层额外的安全保障，攻击者要想获得这笔资金就需要同时获取加密密钥以及密码。这个做法是不错，但用户往往会需要多个钱包，这意味着他们会有多个密钥。对每个NEP-2加密密钥都加以存储是非常麻烦的，因此我们可以创建一种文件结构来一并存储所有这些加密的密钥。

该标准提供了一种将钱包导入各种区块链客户端的标准化方法，并提供了对NEP-2格式额外的安全性保证。

可以在此处查看有关文件格式的完整规范说明（https://github.com/neo-project/proposals/blob/master/nep-6.mediawiki） 。 文件遵循JSON结构，其中包含有关私钥/公钥对的信息以及每个账户的元数据信息。元数据包含如下信息：应将哪个钱包设置为默认钱包、加密参数以及任何其他相关的元数据。

NEP-6文件还支持watch-only模式的地址。Watch-only地址不包含与私钥相关的任何信息，如果账户是单独存储在一个更为安全的位置的话，这个功能可能会很有用。

## 合约账户
NEO还支持更加复杂的账户类型。 在这些类型中，资金不与单个用户相关联，而是存储在智能合约中。 合约将包括一些特殊规则，这些规则定义了从账户中提取资金所需的条件。

这种账户类型最常见的是多签名账户。 多签名账户要求X个人中有N个人为交易提供签名从而进行资金转账。 例如，3个账户所有者中必须要有2个对交易进行签名从而才能提取资金。

我们可以使用NEO的操作码为此账户生成一个简单的合约。假设我们想为三个不同的人（公钥）创建一个多签名合约账户：

**需要注意的是，我们需要在操作之前按ECPoint（X，Y）对公钥进行升序排序，否则我们将得到一个不同的脚本哈希，从而导致生成不同的NEO地址。**

```
//公钥1
036245f426b4522e8a2901be6ccc1f71e37dc376726cc6665d80c5997e240568fb

//公钥2
0303897394935bb5418b1c1c4cf35513e276c6bd313ddd1330f113ec3dc34fbd0d

//公钥3
02e2baf21e36df2007189d05b9e682f4192a101dcdf07eed7d6313625a930874b4
```

我们希望至少有两个人对交易进行签名。 因此，为达到这个目的我们必须创建一个自定义脚本。 脚本内容如下：

```
// 最少签名数(2)
PUSH OPCODE 52

// 附上所有的公钥
PUSH PUBKEY 1
PUSH PUBKEY 2
PUSH PUBKEY 3

//公钥总数 (3)
PUSH OPCODE 53

//检验多签
PUSH OPCODE AE
```

从而得到了如下的脚本
```
5221036245f426b4522e8a2901be6ccc1f71e37dc376726cc6665d80c5997e240568fb210303897394935bb5418b1c1c4cf35513e276c6bd313ddd1330f113ec3dc34fbd0d2102e2baf21e36df2007189d05b9e682f4192a101dcdf07eed7d6313625a930874b453ae
```

然后，我们使用前面描述过的方法计算该账户的脚本哈希和地址。

计算脚本哈希（和地址）：
4d0c0932fa032debdceaaf5cd8086cf3f882961f / AJetuB7TxUkSmRNjot1G7FL5dDpNHE6QLZ

*多方签名示例由NEOResearch提供*

这个合约信息也可以存储在NEP-6文件中，从而允许用户跟踪那些不一定与单个私钥相关联的账户。 可以使用NEO的脚本功能来创建更加复杂的账户类型。

NEO-GUI钱包目前支持多方签名。

### NEO DB3
在引入NEP-6文件格式之前，NEO db3是NEO GUI先前所支持的一种遗留的文件格式。强烈建议升级到NEP-6文件格式，这可以在NEO-GUI中完成。
https://docs.neo.org/en-us/node/gui/wallet.html


## UTXO 模型
钱包的主要功能之一是方便进行资产转移。NEO中的资产分为两类。一种基于UTXO模型（未花费的交易输出），另一种则是基于账户模型。在NEO中，NEO和GAS都遵循UTXO模型，而NEP-5代币则遵循账户模型。下面让我们详细地讨论下这两个模型。

首先，让我们来考虑下用户持有10个NEO的简单示例。这10个NEO实际上由多个UTXO组成。所有UTXO的总和必须等于10。例如，这10个NEO可能由3个UTXO组成。 UTXO_1为2 NEO，UTXO_2为3 NEO，UTXO_3为5 NEO，三者相加的余额总计是10 NEO。因此，如果我们需要给别人发送3个NEO，那么我们可以简单地使用UTXO_2中的3个NEO作为交易的输入，而接收方接收到的作为输出的UTXO也是3 NEO。

如果想尝试发送5个NEO，那么我们可以将UTXO_1和UTXO_2组合在一起作为交易输入，而接收方会收到作为交易的单个输出的5个NEO。当我们需要发送的金额不能通过对UTXO进行组合求和来满足时，情况就会变得稍微复杂一些。

现在我们想要向他人发送4个NEO。对UTXO进行组合无法直接得到这4个NEO。我们所能做的就是同时使用UTXO_1和UTXO_2，组合得到5个NEO。所以我们将UTXO_1和UTXO_2作为交易的输入，但与之前只有单一的输出不同，这时我们需要输出2个UTXO。为接收方生成一个值为4 NEO的UTXO，然后创建一个值为1 NEO的UTXO作为零钱发送回我们的账户。

对于核心的NEO交易，必须满足以下这个公式，才能被认为是网络上的有效交易。Sum(NEO_i) + Sum(GAS_i) = Sum(NEO_o) + (Sum(GAS_I) - Sum(GAS_sys_fee) - Sum(GAS_net_fee))

从这个意义上说，UTXO不会被创建或销毁，而是会在新的UTXO中重新使用。加入UTXO可以并行地执行交易，因为每个UTXO都是唯一的，因此不可能出现双花的情况。

## 账户模型
其他一些区块链平台（如以太坊）所使用的账户模型会为每个拥有资金的账户创建一个全局状态。因此，你可以简单地使用与账户相关联的余额10，而不用持有一组用于交易的UTXO。因此，所有账户的全局状态必须本地存储在网络中的节点上。交易通过网络中的虚拟机解释执行，并对全局状态中的所有账户进行相应的状态更改。

在NEO网络上部署的NEP-5资产合约通常都遵循余额存储的账户模型。它们没有关联任何的UTXO数据，余额状态的变化是通过执行智能合约完成的。这些执行由NEO虚拟机进行解释执行，并记录在智能合约存储区中。

### 创建钱包
可以有多种方式创建一个新钱包。

完全同步了区块链数据的，可以考虑
* NEO-GUI -> https://docs.neo.org/en-us/node/gui/install.html
* NEO-CLI -> https://docs.neo.org/en-us/node/cli/cli.html

对于不需要进行同步的轻客户端，可以考虑
* O3 钱包-> https://o3.network/
* NEON 钱包-> https://neonwallet.com/

你可以在相关的钱包链接中查看更详细的使用指南







