# 介绍

多代理系统（MAS）是物联网（IOT）的核心，系统中的自治设备能够按照各自的特定目标彼此交互。
区块链共识以同样的方式运作，自治节点应通过协商协议达成一致。虽然可能有一个需要优化的全局指标，但肯定有一些自私的节点试图最大化他们自己的利益。通常，如整篇文章所述，MAS协议达成一致的三大支柱是：投票、拍卖和协调。

我们相信区块链协议能够在达成共识的过程中安全地执行分布式理性决策。特别是，如果给出正确的激励措施，这种情况是可以发生的。
激励不仅仅是直接的金钱（虽然是奖励），而且还涉及声望以及节点感兴趣的项目的维护。对于NEO共识节点（CN）而言，可以提出这一兴趣的两个关键点，涉及到两个不同的领域：1）有兴趣拥有一个与协助创建区块相关的可靠形象的利益相关者; 2）希望增加Neo持有者对他们信任度的节点，这可以让持有者支持他们的候选资格并使用他们的服务。

NEO协议，即所谓的委托拜占庭容错（dBFT），其设计源于实际拜占庭容错，由Miguel Castro和Barbara Liskov在1999年左右提出。

本教程将介绍一些基本步骤，以便理解为我们的生态系统设计和开发这样的机制的重要性。


## 我们希望你能学到什么

读完完本材料后，你将学到:

- 区分工作量证明机制和其他基于协调的共识机制;
- 了解关于加密和多签名账户的更多信息;
- 了解拜占庭容错系统;
- 理解完全分布式网络的设计，其中共识使用数字签名进行操作;
- 了解**一区块终局性**的美妙之处。

## 工作量证明机制的根本

中本聪提到了的工作量证明机制可以跨CPU投票，即一CPU一票制。这背后的基本思想是创建一个协议，其中每隔“X”秒产生一个新的区块。如果更快或者更慢地生成区块，则难度会降低。

例如，让我们把`NEO Ecosystem`这个词转换成Hash256 `b1f65a74b608f6b785286b5da1d39ceb36ed87b62fee6ba97a65ecd4655b7661`。
现在让我们来看看`NEO Ecosystem + Nonce`这个词，比如说`NEO Ecosystem + 1`，我们将得到下面的Hash256 `0739bcb67c6e934c669b95d65f1c98cdd67bcef0ef8ab22a7c1b4404f0e11450`。
现在，让我们看看`NEO Ecosystem + 12345678`，我们将得到`011c65a33085565814548bc2860a1a3b1c68b627581381382447147788b0240c`，它以`01`开头，没有`07`那么有意义。现在，开始玩转这个随机数，直到你得到以0000000000`开头的值，你可以验证这个任务有多困难。哈希是任何数据文件的一种加密签名，它基于经典的SHA-256算法，可生成几乎唯一的固定大小为32字节长的值。哈希是单向的，即使在量子计算机的帮助下，任何已知的算法都难以恢复其信息。

在比特币挖矿的早期，2009年，一台标准计算机可以达到每秒大约1百万哈希的算力。从那时起，从GPU，FPGA和ASIC发展而来，挖矿的算力已经达到了令人印象深刻的每秒130亿哈希的专用功率，比开始时快1300万左右。

如果专门用于生成哈希的计算机和知识发展得如此之快，为什么数字签名和通信协议不一样呢？物联网一直是知名研究人员和行业工作的热点和焦点，其根源与自治设备之间的通信和协议有关。

NEO dBFT的根本是由一组节点（自治代理）共享的数字签名，这些节点是由大多数NEO持有者选择出来的。

## 协调 x 权益证明 x 投票

众所周知，所谓的基于权益证明（PoS）的算法与我们提到的MAS有相似之处。PoS的核心思想是让那些在生态系统中财务状况较好的人有决策权，这将激励他们保持网络安全高效地运行。可以注意到，如果我们将这种力量转变为生态系统的一部分，我们将拥有一个类似的PoS，其中投票将是选择此类节点的主要机制。使用投票权甚至可以删除那些按照承诺行事的人。

总而言之，我们应该看到协调是在去中心化场景中达成一致的核心。协调的意义不在于中心协调员，而是在于做出决定时考虑多个目标。

## pBFT

有人认为，完全基于异步系统实现共识是不可能的，*M. Fischer, N. Lynch, and M. Paterson*于1985年在ACM期刊上发表的"具有单一故障过程的分布式共识的不可能性"一文提到。

从这个意义上说，我们必须依靠同步的基本概念来提供网络的活性。

可能[9]。我们保证活性，即客户端

有关pBFT的状态图的概述可以查看下图。![Neo 规范](https://github.com/NeoResearch/yellowpaper/blob/master/sections/graphviz-images/graphviz-pbft.jpg?raw=true)

pBFT专为......而设计


## dBFT

**免责声明:** *本教程的部分内容摘自[dBFT正式规范](https://github.com/NeoResearch/yellowpaper/blob/master/sections/08_dBFT.md)。*

虽然前面提到的活性已经被证明用于pBFT机制，但是dBFT工作的场景是一个具有状态机复制机制的现实中的大型公有链。所共享的信息的性质不同，不能泄露。为此，精细且精确设计的恢复机制是dBFT机制的一部分。

可以看到当前的dBFT 2.0状态流![这里](https://github.com/NeoResearch/yellowpaper/blob/master/sections/graphviz-images/graphviz-dbft-v2-recover.jpg?raw=true)

### 一区块终局性

一区块终局性为现实世界的应用程序带来了显著的优势。例如，终端用户，商家和交易所可以确信他们的交易已被最终处理，并且不可能被回退。虽然NEO生态系统是为托管的去中心化应用程序（DApps）而设计的，但值得注意的是，持久化的SC交易（涉及状态机复制（SMR）并且是几个DApp的核心功能）会带来一系列独特的挑战。由于共识节点无法公开和显示任何重复区块的信息，因此保证区块终局性是一项棘手的任务。从这个意义上讲，只有当大多数共识节点已经达成协议时，才应提供区块的签名。

这个问题被称为**不知疲倦的矿工问题**（在此定义）：

1. 该议长是一名地质工程师，正在寻找一个可以挖掘氪石的地方;
1. 他提议了一个地理位置（待挖掘的地理坐标）;
1. 团队中的大多数成员(`M` 个人)对该坐标达成了共识（带有他们的签名）并签署了合约同意开始挖掘;
1. 挖掘的时间：他们会不停地挖掘，直到他们找到氪石（在发现氪石前不会去任何其他地方进行挖掘）。氪石是一种无限可分的晶体，因此，一旦有人挖掘到氪石，他就可共享以便所有人都能拥有一块氪石从而履行完他们的合约（3.）;
1. 如果有人死亡了，当有其他人加入时，他将看到先前签署的协议（3.），并自动开始挖掘。其他小部分人也会遇到相同的问题，可以通过隐藏的信息来告知他们也应该进行挖掘。

### 出块更改视图且给予网络额外的时间

为了保持活性，需要保证具备一些额外的性质：

 - 如果节点不相信当前的网络拓扑结构，则应阻止节点提交它们的签名（请求`更改视图`）。

然而在实践中，总结为Commit阶段锁定，dBFT在某些情况下会失去活性，其中节点只是存在网络问题。此问题的解决方法是引入计数机制，用于检查已提交的节点（易于检查）和故障的节点（在最近这些区块的生成过程中没有连接过的节点）。在要求改变视图之前，该机制提供了额外的保护层。

与此同时，设计的另一个策略是当节点看到网络有进展时，避免`change_view`。从这个意义上说，每次节点在节点之间共享签名信息时，会将额外的超时添加到它们的内部计时器中，总结出节点正在达成协议并在它们之间进行通信。

### 一个由4个节点组成的共识

正如你可能已知的那样，NEO区块链2.x中的地址由`21`组成，这意味着[“向计算栈推送34个字节”](https://github.com/neo-project/neo-vm/blob/f81c3039d5fb4417b3c1ad780378c7f92499964a/src/neo-vm/OpCode.cs＃L144), 公钥和`ac`，它是一个操作码，用于调用脚本来验证地址的见证人。

我们建议读者看看以下文章：

 -  [了解NEO上的多方签名](https://medium.com/neoresearch/understanding-multisig-on-neo-df9c9c1403b1)。

让我们考虑具有以下公钥的节点（21 + rootOfPubKey + ac）：

 -  N1：`2102103a7f7dd016558597f7960d27c516a4394fd968b9e65155eb4b013e4040406eac`
 -  N2：`2102a7bc55fe8684e0119768d104ba30795bdcc86619e864add26156723ed185cd62ac`
 -  N3：`2102b3622bf4017bdfe317c58aed5f4c753f206b7db896046fa7d774bbc4bf7f8dc2ac`
 -  N4：`2103d90c07df63e690ce77912e10ab51acc944b66860237b608c4f8f8309e71ee699ac`

基本上，创建多方签名账户的简单方法可以使用以下脚本完成：

`532102103a7f7dd016558597f7960d27c516a4394fd968b9e65155eb4b013e4040406e2102a7bc55fe8684e0119768d104ba30795bdcc86619e864add26156723ed185cd622102b3622bf4017bdfe317c58aed5f4c753f206b7db896046fa7d774bbc4bf7f8dc22103d90c07df63e690ce77912e10ab51acc944b66860237b608c4f8f8309e71ee69954ae`

这是：`53`（签名个数）+`21` +`02 ... 6e` +`21` + `02 ... 62` +`21` + `02 ... c2` +`21`+`03 ... 99` +`54`（公钥所有者个数）+`ae`

我们选择这4个节点作为他们想要的验证人，下面的脚本将为每个区块提供签名，具有以下公共地址：`AZ81H31DMWzbSnFDLFkzh9vHwaDLayV7fU`。后者可以通过将该脚本转换为“大端格式的脚本哈希”再然后转换为base-58格式来实现。如果读者想要试着转换格式的话，我们建议访问[NeoCompiler-Eco](https://neocompiler.io/#!/ecolab/conversor)。

![multisig 3/4](./multisig_3_4.png)

![scripthash to address base58](./scripthash_address.png)

### 一个简单地单节点的共识

让我们以前面描述的第一个节点（N1）为例，通过将`53`和`54`转换为`4f`，来创建一个包含1个所有者和一个签名者的多方签名账户。

`512102b3622bf4017bdfe317c58aed5f4c753f206b7db896046fa7d774bbc4bf7f8dc251ae`

后者将产生以下地址：`AbU69m8WUZJSWanfr1Cy66cpEcsmMcX7BR`

### Watch-only模式的共识节点

正如可以在[网络教程](linkToNetworkTODO)中验证的那样，NEO网络以完全分布式的方式运行，如上图所示，摘自[Medium文章](https://medium.com/neoresearch/understanding-neo-network-in-five-pictures-e51b7c19d6e0):

![转发交易，直至达到共识节点（绿色）](https://cdn-images-1.medium.com/max/800/1*vKbm_Di8GgQep8SyKeAWNw.png)

绿色框代表共识，出现在节点池中。消息全部广播给相邻节点（在最佳场景中）。具有特殊功能的节点可以设计为仅监控共识节点的P2P消息，可以访问[NeoCompiler Eco共享私有链](https://neocompiler.io/#!/ecolab/cnnodesinfo)来查看。

![仅限监视节点的信息](./watch-only-node.png)

在这个图中，该Watch-Only节点还具有RPC功能。值得注意的是，节点可以具有特殊功能，并总结管理该客户端所需的任何信息，如[教程](./linkToPluginsTodo)中所强调的那样。

### dBFT 场景

为了举例说明一些可能的共识场景，让我们考虑以下角色：

![dBFT共识节点角色](./cn_characters.jpeg)

 -  **N1：** 张铮文，绝地大师 ;
 -  **N2：** 达鸿飞，智能经济的壁炉;
 -  **N3：** 林鹏涛，壁炉中的真相;
 -  **N4：** NEO 生态系统，用户、交易所和开发人员的所有项目和利益的总和;
 -  **N5：** City of Zion，世界各地的结合和合作;
 -  **N6：** NeoResearch Buterfly，探索、恢复和改造的能力;
 -  **N7：** 尤达大师，从过往的经验中学习。

通过使用这7个共识节点及其优点，我们将给出一些例子，可以让读者了解dBFT是如何工作的：

#### 创世块

创世块创建了3个交易，其中原生资产NEO和GAS在其祖先的教导下神奇地创建出来，并转移到当前验证人的账户中（由这7个角色组成的多方签名账户）;

#### 情况 1 (正常运行)

- 我们处于高度`1`以及视图编号`0`, 议长节点是`N1`(考虑一个数学公式);
- 张铮文选择了由多签账户签名的第一组交易，并且发起了提案块`b_1_0`;
- 需要`2f+1`个节点对该提案达成一致。N2, N3, N4 and N5是首先响应希望处理这个区块的节点。包括N1,现在有5个节点 (正好是2f +1);
- N1, ..., N5可能会首先进入提交阶段。
- 处于提交阶段的节点会自动发送针对当前区块提案`b_1_0`的签名;
- 一旦节点收集到`2f+1`个签名，就会向网络广播一个有效地区块。即便是一个**watch-only模式的节点**也可能是第一个执行该任务的节点(突出显示了这个MAS环境可能的工作方式)。

#### 情况 2 (议长故障)

- 现在我们处于高度`2`且视图编号为`0`, 议长节点是`N2`;
- 达鸿飞小睡了一会儿，在这几秒钟内无法与其他角色交流了;
- `2f+1`个节点同意应该`更改视图`。网络上没有任何进展，节点应该严格按照将`出块时间`左移1位来设置超时时间。如果是15秒，则超时时间是30秒。
- 议长节点更改为N3。
- N3节点只有在参与`视图更改`的情况下才会发起新的提案块, 否则, 它仍将等待`N2`的提案块。
- 考虑到N3得到了`2f+1`条`更改视图`消息, 它现在将发起新的提案块`b_2_1`;
- 从这里开始执行情况1下的正常流程。

#### 情况 3 (提交之后发生故障)

- 现在我们处于高度`3`以及视图`0`, 议长节点是`N3`;
- N3发起了提案块`b_3_0`;
- 从`N3`, ..., `N7`开始的大多数节点都同意提案;
- 然而，在进入提交节点后，`N4`在广播其对区块`b_3_0`的签名前发生故障了;
- `N3`, `N5`, `N6` 以及`N7`，现在只有`2F`个节点，仍然还需要一个对`b_3_0`的签名。 可能的情况是: 1) `N4`从故障中恢复了; 2) `N1`以及`N2`可以看到它们丢失的消息; 3) `N1`和`N2`请求`更改视图`，但不会获得大多数`M` 的同意，其他节点将发送一条`Recovery`消息来响应它们, 在该消息中，它们将自动接收到所有已知的消息。一旦这3个节点中的任何一个收到此类消息，它们将对当前区块`b_3_0`进行操作。

需要注意的是，3个故障节点个数是`f+1`，这会阻止网络的运行。另一方面，应该注意的是，没有检测到真正的拜占庭行为，这只是延迟和连接的问题。从这个意义上来说，由于部分同步协议，消息有时会达到这些节点.

#### 情况 4 (议长节点出现拜占庭)

- 现在我们处于高度`4`且视图编号为`0`, 议长节点是`N4`;
- `N4`是恶意节点，且试图向网络发送一个不同的区块;
- 每个节点设计为只接受每个`视图`下的单的提案。在大多数`M = 2f+1`个节点不能就同一个提案达成共识之前(通过`hash`汇总)，不会提交任何节点。
- 如果`M`个节点提交了而另外的`f = 2`个节点缓存了一个不同的提案块，它们将在某个时刻收到一条`Recover`消息, 这将允许它们匹配哈希值。如果哈希值不同，我们将有一个针对这个议长节点的反证，这肯定会使得NEO持有者将这个节点从验证人中删除。


## 实践练习(动手操作)

我们建议那些对初始化和测试这种共识感兴趣，且能轻松跟踪日志的人，花一些时间来查看下[NeoCompiler Eco Github](https://github.com/neoresearch/neocompiler-eco),按照上面的指南来搭建一个本地的区块链系统。

按照[README](https://github.com/neoresearch/neocompiler-eco/blob/master/readme.md)以及其中描述的步骤，根据所需规范来初始化你的共识节点。